# Security
As Kubernetes is a reliable, production-grade solution to hosting applications, security is an important issue.

As the API server is what communicates to internal components and external access, it is the first line of defense.

Security in Kubernetes controls **who can access the cluster** ([[#^8c9d4f]]) and **what can they do** ([[#^e8e0d8]]).

All communication between Kubernetes components are secured with <span style = "color:lightblue">TLS encryption</span>.

By default, communication between applications in a pod is not restricted; however, this can be changed with <span style = "color:lightblue">network policies</span>.

## Authentication
^8c9d4f

There are several mechanisms for authenticating a connection.
- files
	- usernames and passwords
	- usenames and tokens
- certificates
- external authentication providers (e.g., LDAP)
- service accounts (*for bot integration*)

All cluster administrative access is handled by the API server.

It is noted that usage of static files for authentication **is not recommended** as it is **not secure**. In fact, they are deprecated since version `1.19`, and other authentication methods are used instead.

### Files
#### Static Password File
Credentials can be provided in a `.csv` file, where each entry contains a password, username, user ID, and, optionally, a user group.

```
password123,user1,u0001,group1
```

This path of the authentication file can be passed into the API server service with the `--basic-auth-file` option.

If the API server is run as a pod (*static pod*), the above option is added to the `command` field in the YAML configuration file.

When accessing a cluster configured this way, the username and password are specified with the `-u` option, where the username and password are separated by a `:`. An example is shown below.

```bash
curl -v -k https://ip:6443/api/v1/pods -u "user:password"
```

#### Static Token File
Tokens can be also provided in a `.csv` file. Each entry contains a token, username, user ID, and, optionally, a user group.

```
KpjCVbI7rCFAHYPkByTIzRb7gu1cUc4B,user1,u0001,group1
```

A token file is specified with the `--token-auth-file` option.

Access to a cluster configured this way requires the `--header` option followed by the token in the following format: `"Authorization: Bearer <TOKEN>"`. An example is shown below.

```bash
curl -v -k https://ip:6443/api/v1/pods --header "Authorization: Bearer KpjCVbI7rCFAHYPkByTIzRb7gu1cUc4B"
```

### Transport Layer Security (TLS)
In any communication between two parties over a network, trust must be guaranteed to ensure that information sent is only received by intended parties.

The <span style = "color:lightblue">public key infrastructure (PKI)</span> is the security infrastructure that uses security keys and certificates to secure a connection and authenticate the identity of parties.

#### Security Keys
An <span style = "color:lightblue">encryption key</span> encrypts information (i.e., a message) which can be only read again if it is decrypted by the same key.

In <span style = "color:lightblue">symmetric encryption</span>, the same encryption key is used to encrypt and decrypt data and **must also be sent over the network** (*the other party needs to read it as well*). This encryption method compromises the system.

In <span style = "color:lightblue">asymmetric encryption</span>, there is a pair of encryption keys: a <span style = "color:lightblue">private key</span> and a <span style = "color:lightblue">public key</span>. A public key is shown to everyone but can only be decrypted by the private key.

> [!INFO]
> In reality, information can be encrypted by both the public key *or* the private key; however, it can only be decrypted by the other key that was not used to encrypt it.

To ensure a connection is safe, both symmetric and asymmetric encryption methods are used. Asymmetric encryption encrypts the symmetric key to allow both parties to have access to the same key. With this, both parties can send encrypted information and decrypt them with the exchanged key.

#### Certificates
A <span style = "color:lightblue">certificate</span> is used to validate the authenticity of the other party (*used together with security keys*). All certificates will contain details about the identity of the host (e.g., issuer, aliases, other recognized URLs, signature, etc.).

> [!INFO]
> All browsers have built-in certificate signature validation and will warn the user about fake certificates.

However, a certificate can be generated by anyone. <span style = "color:lightblue">Self-signed certificates</span> do not have a proper validated signature.

A <span style = "color:lightblue">certification authority (CA)</span>, which is a trusted entity, will validate a generated certificate through a <span style = "color:lightblue">certificate signing request (CSR)</span>. Once the certificate is received and the information is validated, the authority will send back a signed certificate with a trustable signature (<span style = "color:lightblue">root certificates</span>).

The certificate authorities have intricate methodologies to ensure that a user is, in fact, the owner of a domain.

To authenticate the **identity** of a certificate authority, each authority has public and private keys that are built into a browser.

> [!INFO]
> Trusted certification authorities can be found in the browser.
> 
> For **Google Chrome**, navigate to `chrome://settings` and search for **Manage certificates**. The pop-up window will show trusted authorities under **Trusted Root Certification Authorities**.

Some certificate authorities include Symantec, GlobalSign, and digicert.

Certification authorities also provide private authorization for websites and domains for **within an organization** (*authorization detailed above is for public websites*).

Occassionally, the client may *also* be required to generate an authority-validated certificate (<span style = "color:lightblue">client certificates</span>) to ensure that the client communicating to the host is indeed the client.

**Public keys are used with certificates (<span style = "color:lightblue">server certificates</span>) to ensure that the party a user is communicating with is authentic.**

#### Filename Conventions
Certificates (public keys) are commonly `.crt` or `.pem` files.
- server certificates: `server.crt` or `server.pem`
- client certificates: `client.crt` or `client.pem`

On the other hand, private keys are commonly a `.key` file or a `.pem` file with the term `key` in it.
- server private key: `server.key` or `server-key.pem`
- client private key: `client.key` or `client-key.pem`

#### Kubernetes
Kubernetes requires server certificates for servers. In a Kubernetes architecture, the servers are the main API server, the ETCD cluster, and the kubelets.

Kubernetes also requires client certificates for clients who are the scheduler, the controller manager, the proxy, and external administrators (*us!*).

All entities generate a certified public key and a private key. For example, the API server could generate the following key pair files: `apiserver.crt` and `apiserver.key`.

Although the API server both acts as a server (i.e., listens for requests from the scheduler, the controller manager, the proxy, and administrators) and a client (i.e., sends requests to the ETCD cluster and the kubelets), it can use the **same key pair for receiving and sending**. Alternatively, a new key pair can be generated for sending requests.

Lastly, Kubernetes requires a certification authority to sign certificates. There can be multiple certification authorities.

#### Certificate Creation
There are several methods, such as <span style = "color:lightblue">Easy RSA</span>, <span style = "color:lightblue">OpenSSL</span>, and <span style = "color:lightblue">CFSSL</span>, to generate certificates for the Kubernetes cluster. This document will describe the process of certificate creation using OpenSSL.

It is noted that the <span style = "color:lightblue">master node</span> acts as the Kubernetes certification authority and self-signs certificates.

##### Certification Authority

^618f22

As shown below, a private key for the certification authority is generated.

```bash
openssl genrsa -out ca.key 2048
```

The two code blocks below send a certificate signing request (*no certificate*) and self-sign the certificate respectively.

```bash
openssl req -new -key ca.key -subj "/CN=KUBERNETES-CA" -out ca.csr
```

```bash
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```

##### Client
Similar to the certification authority, a key and a certificate are generated. These files are created to authorize with the API server (i.e., a client role).

```bash
openssl genrsa -out admin.key 2048
```

```bash
openssl req -new -key admin.key -subj "/CN=kube-admin" -out admin.csr
```

It is noted that the value of the  `-subj` argument does not have to be `kube-admin`, but it is the **name that the Kubernetes cluster authenticates with**.

> [!INFO]
> The `CN` keyword refers to the **certificate name**.

```bash
openssl req -new -key admin.key -subj "/CN=kube-admin/O=system:masters" -out admin.csr
```

Additional permissions can be specified with group assignment. The above code block adds the group `system:masters` to the certificate, which allows administrative privilleges.

Kubernetes components (i.e., non-user clients) have the `system:` keyword appended to the beginning of the certificate name.

```bash
openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt
```

The authority's key and certificate are also provided when signing to generate a <u>valid</u> certificate.

##### Server
A key and a certificate are also generated for each Kubernetes server component. They would need to be verified by the Kubernetes certification authority generated in [[#^618f22]] as well. The generation process is identical to that of for clients.

However, if there are multiple servers running (e.g., **ETCD servers**), additional <span style = "color:lightblue">peer certificates</span> must also be created.

In the case of the **API server**, there can be additional aliases, which must be indicated in the certificate, to refer to it. An additional certificate configuration file is inputted during the creation process.

```bash
openssl req -new -key apiserver.key -subj "/CN=kube-apiserver" \
-out apiserver.csr -config openssl.cnf
```

A sample `.cnf` file configuration is shown below. It is noted that the alternative aliases (DNS and IP) are specified under `alt_names`.

```CNF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation
subjectAltName = @alt_names
[alt_names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster.local
IP.1 = 10.96.0.1
IP.2 = 172.17.0.87
```

Additionally, client keys and certificates must also be created for the API server, so that it can connect to the other Kubernetes components (e.g., kubelets and ETCD servers).

Likewise, both client files and server files are required for **kubelets**. For client-side certificates, the `system:node:` keyword must be appended to the beginning of the certificate name to specify that the entity is a system component and is a node. Additionally, kubelet certificates must also be part of the `system:nodes` group.

#### Health Check
Existing certificate configurations can be viewed in the arguments either in the service configuration (*component run as a service*) or in the static pod definition file (*component run as a pod*).

```bash
cat /etc/systemd/system/kube-apiserver.service
```

```bash
cat /etc/kubernetes/manifests/kube-apiserver.yml
```

A certificate can be decoded and viewed in plain text.

```bash
openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout
```

Logs can also be viewed for troubleshooting. Log viewing for both services and pods are shown below.

```bash
journalctl -u etcd.service -l
```

```bash
kubectl logs <POD_NAME>
```

In the case that core components, such as the API server, are not functioning, the logs in the Docker container are inspected instead.

```bash
docker ps -a
docker logs <CONTAINER_ID>
```

A sample checklist for certificate health status is found in the source folder.

#### Certificate API
Kubernetes has an API to handle certificates automatically. First, a key and a certificate signing request (CSR) are generated as denoted in the above sections. A `CertificateSigningRequest` object is created using a YAML file to handle the individual CSR.

```yaml
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
	name: <NAME>
spec:
	groups:
	- system:authenticated
	usages: 
	- digital signature
	- key encipherment
	- server auth
	signerName: kubernetes.io/kube-apiserver
	request: LS0tLS1CRUdJTiBDRVJU (values hidden...)
```

The `signerName` must also be provided. The request in the `request` field does not contain the actual CSR. Instead, it is encoded in `base64`.

```bash
cat <FILENAME>.csr | base64 | tr -d "\n"
```

CSRs can be viewed, approved, and rejected using the following code blocks respectively.

```bash
kubectl get csr
```

```bash
kubectl certificate approve <CSR_NAME>
```

```bash
kubectl certificate deny <CSR_NAME>
```

Approved CSRs can be viewed under the `status.certificate` field in the YAML output.

```bash
kubectl get csr <CSR_NAME> -o yaml
```

```bash
echo "<ENCODED_CERT>" | base64 --decode
```

The certificate must be decoded to view the plain text which can then be shared to users.

The certificate API is handled by the controller manager component, specifically the <span style = "color:lightblue">csr-approving</span> and <span style = "color:lightblue">csr-signing</span> sub-components, in the Kubernetes cluster. The certification authority key and certificate files are specified with the `--cluster-signing-key-file` and `--cluster-signing-cert-file` options respectively.

#### Kube Config
Client keys and certificates can be inputted as arguments in a simple REST API call or with the `kubectl` command to the server.

```bash
curl https://kube-apiserver:6443/api/v1/pods \
--key admin.key --cert admin.crt --cacert ca.crt
```

```bash
kubectl get pods --server kube-apiserver:6443 --client-key admin.key
\ --client-certificate admin.crt --certificate-authority ca.crt
```

**Alternatively, a <span style = "color:lightblue">kube config</span> can store key and certificate authorization details in a YAML file.** A kube config consists of **clusters** (*various clusters*), **contexts** (*user-cluster pairing*), and **users** (*pre-existing users*).

```yaml
apiVersion: v1
kind: Config

current-context: my-kube-admin@my-kube-server

clusters:
- name: my-kube-server
  cluster:
    certificate-authority: /etc/kubernetes/pki/ca.crt
    server: https://kube-apiserver:6443

contexts:
- name: my-kube-admin@my-kube-server
  context:
    cluster: my-kube-server
    user: my-kube-admin
    namespace: finance

users:
- name: my-kube-admin
  user:
    client-certificate: /etc/kubernetes/pki/users/admin.crt
    client-key: /etc/kubernetes/pki/users/admin.key
```

> [!INFO]
> It is recommended to specify the full path to the key and certificate files. Optionally, there are fields (`certificate-authority-data`, `client-certificate-data`, `client-key-data`) that specify a `base64` encoded string of text of the certificate instead of the file path.

For example, the above file contains one context that creates access to the `finance` namespace in the `my-kube-server` cluster with the `my-kube-admin` user. Multiple clusters, contexts, and users can be created as required. A Kubernetes object does not need to be created, as the `kubectl` command reads directly from the file.

```bash
kubectl config view
```

The `current-context` field will specify the default context to use. The `use-context` subcommand will change the current context to a pre-defined context. Any changes made with the `kubectl` command will be reflected in the YAML file.

```bash
kubectl config use-context <CONTEXT_NAME>
```

The file can be specified in the command line with the `--kubeconfig` option. Alternatively, the `kubectl` command will automatically look for a kube config file in `$HOME/.kube/config`, thus removing the need to explicitly specify the configuration file.

## API Groups
Each group contains API endpoints to different functions. The `/api` group contains endpoints to core functionality, such as pods, namespaces, nodes, and more. On the other hand, the `/apis` category refers to <u>named</u> functionality.

Under each API group, there are <span style = "color:lightblue">resources</span> that can be interacted with. The possible interactions, such as **GET**, **POST**, **DELETE**, etc., with each resource are referred to as <span style = "color:lightblue">verbs</span>. The two code blocks below will list the available API groups and the named (i.e., `apis`) resource groups respectively.

```bash
curl http://localhost:6443 -k
```

```bash
curl http://localhost:6443/apis -k | grep "name"
```

> [!INFO]
> When using the above commands, authentication **must** also be provided.

Authorization controls access to specific groups and resources.

## Authorization
^e8e0d8

There are several options for authorizing a connection.
- <span style = "color:lightblue">role-based access controls (RBAC)</span>: assigning permissions to a general role which can be applied to users or a group of users
- <span style = "color:lightblue">attribute-based access controls (ABAC)</span>: assigning permissions directly to an attribute (e.g., a user or a group of users) through <span style = "color:lightblue">policy files</span>
- <span style = "color:lightblue">node authorization</span>: special authorization for nodes
	- authentication is done through keys and certificates as shown in [[#^8c9d4f]]
	- all certificate whose names begin with `system:node:` and with the `system:nodes` group are given node authorization
- <span style = "color:lightblue">webhook</span>: enables external third-party software (e.g., Open Policy Agent) to handle authorization
- always allow: allows all requests
- always deny: denies all requests

> [!INFO]
> In ABAC, whenever there are changes to the permission rules, the API server must be restarted before the changes take effect. Thus, ABAC controls are difficult to manage.

The authorization mode is set in the `--authorization-mode` option when the API server is run. By default, the mode is set to **always allow requests**. Multiple modes can be specified, where the request will be checked by each module until the authorization is successful.

### Role-based Access Controls (RBAC)
A <span style = "color:lightblue">role</span> can be created with a YAML definition file.

```yaml
# FILENAME: dev-role.yml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: dev
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["list", "get", "create", "update", "delete"]
- apiGroups: [""]
  resources: ["ConfigMap"]
  verbs: ["create"]
```

```bash
kubectl create -f dev-role.yml
```

In the above example, the `dev` user will be able to list, get, create, update, and delete pods and to create config maps. Rules are added as elements under the `rules` field. For **core groups**, the `apiGroups` field is left as an empty string.

Additionally, the `resourceNames` field can also be provided to restrict  a role to specific names of a resource. For example, the role with the following configuration willl only allow users to get, create, and update pods that are named `blue` and `orange`.

```yaml
# FILENAME: dev-role-resourcenames.yml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: dev
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "create", "update"]
  resourceNames: ["blue", "orange"]
```

Next, the role is assigned to user(s) with a `RoleBinding` object.

```yaml
# FILENAME: devuser-dev-binding.yml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: devuser-dev-binding
subjects:
- kind: User
  name: dev-user
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: dev
  apiGroup: rbac.authorization.k8s.io
```

```bash
kubectl create -f devuser-dev-binding.yml
```

Multiple users can be assigned to a role. The `subjects.kind` field can be changed to `Group` to specify a group instead of a single user.

> [!INFO]
> The **roles** and **role bindings** are within the scope of namespaces. If the `metadata.namespace` field is specified, the roles and role bindings will take effect in the non-default namespace.

The `get` and `describe` command can be used to get and describe respectively roles and role bindings.

```bash
kubectl get roles
```

```
kubectl get rolebindings
```

```bash
kubectl describe role <ROLE_NAME>
```

```bash
kubectl describe rolebinding <BINDING_NAME>
```

Role access can also be checked and verified with the `can-i` command. The following code blocks check if the current user can create deployments and delete nodes respectively.

```bash
kubectl auth can-i create deployments
```

```bash
kubectl auth can-i delete nodes
```

Additionally, administrative users can *impersonate* other roles with the `--as` option to verify that the permissions are indeed allowed or restricted as indicated.

```bash
kubectl auth can-i create deployments --as dev
```

```bash
kubectl auth can-i create pods --as dev
```

The `--namespace` option will also specify the namespace.

```bash
kubectl auth can-i create pods --as dev --namespace test
```