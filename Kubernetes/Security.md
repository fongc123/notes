# Security
As Kubernetes is a reliable, production-grade solution to hosting applications, security is an important issue.

As the API server is what communicates to internal components and external access, it is the first line of defense.

Security in Kubernetes controls **who can access the cluster** ([[#^8c9d4f]]) and **what can they do** ([[#^e8e0d8]]).

All communication between Kubernetes components are secured with <span style = "color:lightblue">TLS encryption</span>.

By default, communication between applications in a pod is not restricted; however, this can be changed with <span style = "color:lightblue">network policies</span>.

## Authentication
^8c9d4f

There are several mechanisms for authenticating a connection.
- files
	- usernames and passwords
	- usenames and tokens
- certificates
- external authentication providers (e.g., LDAP)
- service accounts (*for bot integration*)

All cluster administrative access is handled by the API server.

It is noted that usage of static files for authentication **is not recommended** as it is **not secure**. In fact, they are deprecated since version `1.19`, and other authentication methods are used instead.

### Files
#### Static Password File
Credentials can be provided in a `.csv` file, where each entry contains a password, username, user ID, and, optionally, a user group.

```
password123,user1,u0001,group1
```

This path of the authentication file can be passed into the API server service with the `--basic-auth-file` option.

If the API server is run as a pod (*static pod*), the above option is added to the `command` field in the YAML configuration file.

When accessing a cluster configured this way, the username and password are specified with the `-u` option, where the username and password are separated by a `:`. An example is shown below.

```bash
curl -v -k https://ip:6443/api/v1/pods -u "user:password"
```

#### Static Token File
Tokens can be also provided in a `.csv` file. Each entry contains a token, username, user ID, and, optionally, a user group.

```
KpjCVbI7rCFAHYPkByTIzRb7gu1cUc4B,user1,u0001,group1
```

A token file is specified with the `--token-auth-file` option.

Access to a cluster configured this way requires the `--header` option followed by the token in the following format: `"Authorization: Bearer <TOKEN>"`. An example is shown below.

```bash
curl -v -k https://ip:6443/api/v1/pods --header "Authorization: Bearer KpjCVbI7rCFAHYPkByTIzRb7gu1cUc4B"
```

### Transport Layer Security (TLS)
In any communication between two parties over a network, trust must be guaranteed to ensure that information sent is only received by intended parties.

The <span style = "color:lightblue">public key infrastructure (PKI)</span> is the security infrastructure that uses security keys and certificates to secure a connection and authenticate the identity of parties.

#### Security Keys
An <span style = "color:lightblue">encryption key</span> encrypts information (i.e., a message) which can be only read again if it is decrypted by the same key.

In <span style = "color:lightblue">symmetric encryption</span>, the same encryption key is used to encrypt and decrypt data and **must also be sent over the network** (*the other party needs to read it as well*). This encryption method compromises the system.

In <span style = "color:lightblue">asymmetric encryption</span>, there is a pair of encryption keys: a <span style = "color:lightblue">private key</span> and a <span style = "color:lightblue">public key</span>. A public key is shown to everyone but can only be decrypted by the private key.

> [!INFO]
> In reality, information can be encrypted by both the public key *or* the private key; however, it can only be decrypted by the other key that was not used to encrypt it.

To ensure a connection is safe, both symmetric and asymmetric encryption methods are used. Asymmetric encryption encrypts the symmetric key to allow both parties to have access to the same key. With this, both parties can send encrypted information and decrypt them with the exchanged key.

#### Certificates
A <span style = "color:lightblue">certificate</span> is used to validate the authenticity of the other party (*used together with security keys*). All certificates will contain details about the identity of the host (e.g., issuer, aliases, other recognized URLs, signature, etc.).

> [!INFO]
> All browsers have built-in certificate signature validation and will warn the user about fake certificates.

However, a certificate can be generated by anyone. <span style = "color:lightblue">Self-signed certificates</span> do not have a proper validated signature.

A <span style = "color:lightblue">certification authority (CA)</span>, which is a trusted entity, will validate a generated certificate through a <span style = "color:lightblue">certificate signing request (CSR)</span>. Once the certificate is received and the information is validated, the authority will send back a signed certificate with a trustable signature (<span style = "color:lightblue">root certificates</span>).

The certificate authorities have intricate methodologies to ensure that a user is, in fact, the owner of a domain.

To authenticate the **identity** of a certificate authority, each authority has public and private keys that are built into a browser.

> [!INFO]
> Trusted certification authorities can be found in the browser.
> 
> For **Google Chrome**, navigate to `chrome://settings` and search for **Manage certificates**. The pop-up window will show trusted authorities under **Trusted Root Certification Authorities**.

Some certificate authorities include Symantec, GlobalSign, and digicert.

Certification authorities also provide private authorization for websites and domains for **within an organization** (*authorization detailed above is for public websites*).

Occassionally, the client may *also* be required to generate an authority-validated certificate (<span style = "color:lightblue">client certificates</span>) to ensure that the client communicating to the host is indeed the client.

**Public keys are used with certificates (<span style = "color:lightblue">server certificates</span>) to ensure that the party a user is communicating with is authentic.**

#### Filename Conventions
Certificates (public keys) are commonly `.crt` or `.pem` files.
- server certificates: `server.crt` or `server.pem`
- client certificates: `client.crt` or `client.pem`

On the other hand, private keys are commonly a `.key` file or a `.pem` file with the term `key` in it.
- server private key: `server.key` or `server-key.pem`
- client private key: `client.key` or `client-key.pem`

#### Kubernetes
Kubernetes requires server certificates for servers. In a Kubernetes architecture, the servers are the main API server, the ETCD cluster, and the kubelets.

Kubernetes also requires client certificates for clients who are the scheduler, the controller manager, the proxy, and external administrators (*us!*).

All entities generate a certified public key and a private key. For example, the API server could generate the following key pair files: `apiserver.crt` and `apiserver.key`.

Although the API server both acts as a server (i.e., listens for requests from the scheduler, the controller manager, the proxy, and administrators) and a client (i.e., sends requests to the ETCD cluster and the kubelets), it can use the **same key pair for receiving and sending**. Alternatively, a new key pair can be generated for sending requests.

Lastly, Kubernetes requires a certification authority to sign certificates. There can be multiple certification authorities.

#### Certificate Creation
There are several methods, such as <span style = "color:lightblue">Easy RSA</span>, <span style = "color:lightblue">OpenSSL</span>, and <span style = "color:lightblue">CFSSL</span>, to generate certificates for the Kubernetes cluster. This document will describe the process of certificate creation using OpenSSL.

Once the necessary files have been generated, they can be inputted in a REST API call to the cluster as arguments.

```bash
curl https://kube-apiserver:6443/api/v1/pods \
--key admin.key --cert admin.crt --cacert ca.crt
```

A `kube-config.yml` file can be created to store these key and certificate files instead. 

##### Certification Authority
As shown below, a private key for the certification authority is generated.

```bash
openssl genrsa -out ca.key 2048
```

The two code blocks below send a certificate signing request (*no certificate*) and self-sign the certificate respectively.

```bash
openssl req -new -key ca.key -subj "/CN=KUBERNETES-CA" -out ca.csr
```

```bash
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```

##### Client
Similar to the certification authority, a key and a certificate are generated.

```bash
openssl genrsa -out admin.key 2048
```

```bash
openssl req -new -key admin.key -subj "/CN=kube-admin" -out admin.csr
```

It is noted that the value of the  `-subj` argument does not have to be `kube-admin`, but it is the **name that the Kubernetes cluster authenticates with**.

```bash
openssl req -new -key admin.key -subj "/CN=kube-admin/O=system:masters" -out admin.csr
```

Additional permissions can be specified with group assignment. The above code block adds the group `system:masters` to the certificate, which allows administrative privilleges.

Components (i.e., non-user clients) have `system:` appended to the beginning of the certificate name.

```bash
openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt
```

The authority's key and certificate are also provided when signing to generate a <u>valid</u> certificate.



#### 


## Authorization
^e8e0d8

There are several options for authorizing a connection.
- RBAC authorization
- ABAC authorization
- node authorization
- webhook mode

